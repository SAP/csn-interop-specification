"use strict";(self.webpackChunk_sap_csn_interop_specification=self.webpackChunk_sap_csn_interop_specification||[]).push([[1415],{6381:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"primer","title":"Primer","description":"Purpose and Target Group","source":"@site/docs/primer.md","sourceDirName":".","slug":"/primer","permalink":"/csn-interop-specification/primer","draft":false,"unlisted":false,"editUrl":"https://github.com/SAP/csn-interop-specification/tree/main/docs/primer.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"title":"Primer"},"sidebar":"defaultSidebar","previous":{"title":"Overview","permalink":"/csn-interop-specification/"},"next":{"title":"Interface Documentation","permalink":"/csn-interop-specification/spec-v1/csn-interop-effective"}}');var s=t(4848),a=t(8453);const o={sidebar_position:2,title:"Primer"},r="Primer",l={},d=[{value:"Purpose and Target Group",id:"purpose-and-target-group",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Root Level Structure",id:"root-level-structure",level:2},{value:"Definitions",id:"definitions",level:2},{value:"Literals",id:"literals",level:2},{value:"Built-in Types",id:"built-in-types",level:2},{value:"Entity Definitions",id:"entity-definitions",level:2},{value:"Elements",id:"elements",level:3},{value:"Type-specific Properties",id:"type-specific-properties",level:4},{value:"Primary Key",id:"primary-key",level:4},{value:"Optional Properties",id:"optional-properties",level:4},{value:"Annotations",id:"annotations",level:2},{value:"Standard Annotations",id:"standard-annotations",level:3},{value:"Literals for Enum and ElementRef values",id:"literals-for-enum-and-elementref-values",level:3},{value:"Language-dependent annotation values",id:"language-dependent-annotation-values",level:3},{value:"Associations",id:"associations",level:2},{value:"On Condition",id:"on-condition",level:3},{value:"Foreign Key Associations",id:"foreign-key-associations",level:3},{value:"Text Associations",id:"text-associations",level:3},{value:"Context Definitions",id:"context-definitions",level:2},{value:"Aggregation of Data Definitions",id:"aggregation-of-data-definitions",level:3},{value:"Custom Type Definitions",id:"custom-type-definitions",level:2},{value:"Scalar Types",id:"scalar-types",level:3},{value:"Local Built-in Types",id:"local-built-in-types",level:4},{value:"Semantic Types",id:"semantic-types",level:4},{value:"Structured Types",id:"structured-types",level:3},{value:"Inlining",id:"inlining",level:4},{value:"Flattening",id:"flattening",level:4},{value:"Service Definitions",id:"service-definitions",level:2},{value:"Localization (i18n)",id:"localization-i18n",level:2},{value:"Examples",id:"examples",level:2}];function c(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"primer",children:"Primer"})}),"\n",(0,s.jsx)(n.h2,{id:"purpose-and-target-group",children:"Purpose and Target Group"}),"\n",(0,s.jsx)(n.p,{children:"This document shall mainly serve as a reference for development teams who want to produce interoperable data definitions in a development environment w/o native CDS support. (CAP and RAP developers create data models in CDS according to their local development guidelines, and the framework will take care of the interoperability. Datasphere content developers use the modeling tools.)"}),"\n",(0,s.jsx)(n.p,{children:"This document shall also serve as a basic reference for consumers of interoperable data definitions who need to parse, validate and interpret externally provided data documents."}),"\n",(0,s.jsx)(n.p,{children:"Prominent use cases which require the creation and consumption of interoperable data definitions are:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Deployment of HDLF Delta Share Tables in the context of real-time exchange of large datasets"}),"\n",(0,s.jsx)(n.li,{children:"Embedded Analytics on a HANA Cloud side car (plus SAC Integration Service)"}),"\n",(0,s.jsx)(n.li,{children:"Model- and Data Integration with Datasphere"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.a,{href:"https://cap.cloud.sap/docs/cds/csn#core-schema-notation-csn",children:"Core Data Services Schema Notation"}),' (CSN, pronounced "Season") is a JSON format to exchange metadata about data models, e.g., between the various technology stacks and applications that form the Business Technology Platform (BTP).']}),"\n",(0,s.jsx)(n.p,{children:"Depending on the intended usage we distinguish three CSN flavors:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.em,{children:'"Parsed"'})," for the Modeling Perspective"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.em,{children:'"Effective"'})," for the data exchange perspective"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.em,{children:'"Persistency"'})," for the persistency flavor"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.em,{children:'"Parsed"'})," flavor could e.g. represent a CAP CDS data model 1:1, the ",(0,s.jsx)(n.em,{children:'"Persistency"'})," flavor could e.g. express HANA SQL tables and views."]}),"\n",(0,s.jsxs)(n.p,{children:["This document describes the ",(0,s.jsx)(n.em,{children:'"Effective"'})," flavor, characterized as being optimized for data exchange purposes. All content that can be standardized (currency keys, language codes, country codes, \u2026) must be presented in standardized form, hence original data definitions must be adapted accordingly if necessary. Technology-specific aspects of the data model shall be left out as far as possible.\nThis standardization includes the basic data types, and annotation (e.g. labels, \u2026)."]}),"\n",(0,s.jsxs)(n.p,{children:["The document is structured in a way that it starts from an empty JSON document and introduces concepts and their corresponding syntax patterns with development guidance one by one.\nThe example JSON snippets mostly follow the ",(0,s.jsx)(n.a,{href:"./spec-v1/examples/airline",children:"airline example"}),".\nIn order to create a valid Effective CSN document it is only necessary to apply the specification within the intended scope, and the mandatory scope is very small."]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note"}),": According to the purpose the document will evolve. While it is not intended to change any already published content in an incompatible way, new content will be added over time. This implies that early versions of the document will not cover the complete scope of Effective CSN."]}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note"}),": The document quotes frequently from the ",(0,s.jsx)(n.a,{href:"https://cap.cloud.sap/docs/cds/csn",children:"CAP CSN documentation"})," w/o explicit citations. This is done intentionally to increase the consistency between these two sources of information. In case of differences consider that the purpose of this document is not to explain how CSN is derived from CDL, but how Effective CSN is constructed from scratch."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"root-level-structure",children:"Root Level Structure"}),"\n",(0,s.jsx)(n.p,{children:"There are three mandatory root level properties that need to be added to get a minimal valid CSN Interop document:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'{\n  "csnInteropEffective": "1.0",\n  "$version": "2.0",\n  "definitions": { }, // MUST have at least one entry\n}\n'})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"csnInteropEffective"})," states that this JSON document is a CSN Interop document and the value states the version of the spec that was used."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"$version"})," is a mandatory property that defines the version of the general CSN syntax version."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"definitions"})," at least one element of a definition modelling artefact"]}),"\n",(0,s.jsxs)(n.li,{children:["See ",(0,s.jsx)(n.a,{href:"./spec-v1/csn-interop-effective#csn-interop-root",children:"Root Interface documentation"})," for a complete overview."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"definitions",children:"Definitions"}),"\n",(0,s.jsxs)(n.p,{children:["The model is described in the ",(0,s.jsx)(n.a,{href:"./spec-v1/csn-interop-effective#definitions",children:"Definitions"})," section."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'{ //..\n  "definitions": { }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Each entry in the definitions dictionary is a definition of a named modeling artefact. The name is the absolute fully qualified name definition, and the value is a record with the definition details."}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.strong,{children:"name"})," of a definition is its key in the enclosing dictionary."]}),"\n",(0,s.jsxs)(n.p,{children:["Each top-level definitions entry has a property ",(0,s.jsx)(n.strong,{children:"kind"})," \u2013 one of ",(0,s.jsx)(n.code,{children:"entity"}),", ",(0,s.jsx)(n.code,{children:"type"}),", ",(0,s.jsx)(n.code,{children:"service"})," or ",(0,s.jsx)(n.code,{children:"context"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'{ //..\n  "definitions": {\n    "<name>": {\n      "kind": "<kind>"\n    }\n  }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["We will now describe the detail patterns per ",(0,s.jsx)(n.em,{children:"kind"}),". The by far most important ",(0,s.jsx)(n.em,{children:"kind"})," is ",(0,s.jsx)(n.em,{children:"entity"}),". But before we proceed we need to introduce Literals and Built-in Types."]}),"\n",(0,s.jsx)(n.h2,{id:"literals",children:"Literals"}),"\n",(0,s.jsxs)(n.p,{children:["There are several places where ",(0,s.jsx)(n.a,{href:"https://cap.cloud.sap/docs/cds/csn#literals",children:"literals"})," can show up in models, such as in SQL expressions, calculated fields, or annotations.\nStandard literals are represented as in JSON. In addition, CSN specifies special forms for ",(0,s.jsx)(n.em,{children:"references"}),", ",(0,s.jsx)(n.em,{children:"expressions"}),", and ",(0,s.jsx)(n.em,{children:"enum"})," symbols:"]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Kind"}),(0,s.jsx)(n.th,{children:"Example"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Globals"}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"true"}),", ",(0,s.jsx)(n.code,{children:"false"}),", ",(0,s.jsx)(n.code,{children:"null"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Numbers"}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"11"}),", ",(0,s.jsx)(n.code,{children:"2.4"})]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Strings"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:'"foo"'})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Dates"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:'"2016-11-24"'})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Times"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:'"16:11Z"'})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"DateTimes"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:'"2016-11-24T16:11Z"'})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Records"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:'{"foo":\\<Literal\\>, \u2026}'})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Arrays"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"[\\<Literal\\>, \u2026]"})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"References"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:'{"=":"foo.bar"}'})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Unparsed Expressions"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:'{"=":"foo.bar \\< 9"}'})})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Enum Symbols"}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:'{"#":"asc"}'})})]})]})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Remarks:"}),"\n",(0,s.jsx)(n.p,{children:"Numbers share the same issues as in JSON when decimals are mapped to doubles with potential rounding errors. The same applies to Integer64. Use strings to avoid that, if applicable."}),"\n",(0,s.jsxs)(n.p,{children:["Also, as in JSON, dates, and times are represented just as strings as specified in ",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/ISO_8601",children:"ISO 8601"}),"; consumers are assumed to know the types and handle the values correctly."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"built-in-types",children:"Built-in Types"}),"\n",(0,s.jsxs)(n.p,{children:["The CDS ",(0,s.jsx)(n.a,{href:"https://cap.cloud.sap/docs/cds/types#core-built-in-types",children:"built-in types"})," shall be used as basis from which other types (if required) are derived (see ",(0,s.jsx)(n.a,{href:"#custom-type-definitions",children:"Custom Type Definitions"}),")."]}),"\n",(0,s.jsx)(n.h2,{id:"entity-definitions",children:"Entity Definitions"}),"\n",(0,s.jsxs)(n.p,{children:["In this section we introduce ",(0,s.jsx)(n.a,{href:"./spec-v1/csn-interop-effective#entity-definition",children:"entity definitions"})," which would result in a data persistence at deployment, i.e. a table in a SQL database.\nEntity definitions always have kind ",(0,s.jsx)(n.em,{children:"entity"}),", and a property ",(0,s.jsx)(n.em,{children:"elements"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The fully qualified name of the entity is defined as the key in the definition JSON object (",(0,s.jsx)(n.code,{children:"<entity name>"}),")."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'{ //..\n  "definitions": {\n    "<entity name>": {\n      "kind": "entity",\n      "elements": {\n      }\n    }\n  }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"elements",children:"Elements"}),"\n",(0,s.jsxs)(n.p,{children:["Each entry in the ",(0,s.jsx)(n.a,{href:"./spec-v1/csn-interop-effective#elemententry",children:"elements object"})," must have an entity-locally unique name, and a member ",(0,s.jsx)(n.em,{children:"type"})," referring to a built-in type, or a type definition, via its fully qualified name (",(0,s.jsx)(n.code,{children:"<element name>"}),")."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'{ //..\n  "definitions": {\n    "<entity name>": {\n      "kind": "entity",\n      "elements": {\n        "<element name>": {\n          "type": "<type name>"\n        }\n      }\n    }\n  }\n}\n'})}),"\n",(0,s.jsx)(n.h4,{id:"type-specific-properties",children:"Type-specific Properties"}),"\n",(0,s.jsxs)(n.p,{children:["If the built-in ",(0,s.jsx)(n.a,{href:"./spec-v1/csn-interop-effective#cds-type",children:"CDS Types"})," have arguments of type integer (",(0,s.jsx)(n.em,{children:"length"}),", ",(0,s.jsx)(n.em,{children:"precision"}),", ",(0,s.jsx)(n.em,{children:"scale"}),"). These arguments are expressed via additional properties with the (fix) name of the argument. Especially a String has a length, and a Decimal has a precision and a scale. This yields the following specialized patterns:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'{ //..\n  "definitions": {\n    "<entity name>": {\n      "kind": "entity",\n      "elements": {\n        "<string element name>": {\n          "type": "cds.String",\n          "length": <length>\n        },\n        "<decimal element name>": {\n          "type": "cds.Decimal",\n          "precision": <total number of digits>,\n          "scale": <number of decimal places>\n        }\n      }\n    }\n  }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"These additional properties are usually optional.\nHowever, we strongly recommend to always specify them, because otherwise consumer MAY assume different defaults."}),"\n",(0,s.jsx)(n.p,{children:"Note that there are several built-in types for numbers. We recommend to stick to Integer, if there is no specific reason to use a specialized type. And we strongly recommend to use Decimal (not Double) for data exchange."}),"\n",(0,s.jsxs)(n.p,{children:["Note that it's also possible to create shared, reusable types with ",(0,s.jsx)(n.a,{href:"#custom-type-definitions",children:"Custom Types"}),"). With this feature, a new reusable, custom type can be defined in the ",(0,s.jsx)(n.a,{href:"#definitions",children:"Definitions"}),' section ("kind": "type"). Instead of using a native ',(0,s.jsx)(n.a,{href:"./spec-v1/csn-interop-effective#cds-type",children:"CDS Types"}),", the ",(0,s.jsx)(n.code,{children:"type"})," points to the fully qualified name of the derived type. The custom type itself MUST use a native CDS Type however."]}),"\n",(0,s.jsx)(n.h4,{id:"primary-key",children:"Primary Key"}),"\n",(0,s.jsxs)(n.p,{children:["In case the entity has a primary key, it is mandatory to specify it. (It is especially required for data integration with Datasphere.)\nThis is done by adding the member ",(0,s.jsx)(n.em,{children:"key"})," with boolean value ",(0,s.jsx)(n.em,{children:"true"})," to each element of the primary key:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'{ //..\n  "definitions": {\n    "<entity name>": {\n      "kind": "entity",\n      "elements": {\n        "<key element name>": {\n          "type": "<type name>",\n          "key": true\n        },\n        "<non-key element name>": {\n          "type": "<type name>"\n        }\n      }\n    }\n  }\n}\n'})}),"\n",(0,s.jsx)(n.h4,{id:"optional-properties",children:"Optional Properties"}),"\n",(0,s.jsxs)(n.p,{children:["In addition an element has the optional properties ",(0,s.jsx)(n.em,{children:"notNull"}),", and ",(0,s.jsx)(n.em,{children:"default"})," (both with SQL semantics). This results in the pattern:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'{ //..\n  "definitions": {\n    "<entity name>": {\n      "kind": "entity",\n      "elements": {\n        "<element name>": {\n          "type": "<type name>",\n          "key": <true/false>,\n          "notNull": <true/false>,\n          "default": <default value as literal matching type>\n        }\n      }\n    }\n  }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Note: As a general convention we recommend to omit optional boolean properties, if the value is ",(0,s.jsx)(n.em,{children:"false"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"annotations",children:"Annotations"}),"\n",(0,s.jsxs)(n.p,{children:["Annotations are represented as properties, prefixed with ",(0,s.jsx)(n.strong,{children:"@"}),". This format applies to type/entity-level annotations as well as to element-level ones."]}),"\n",(0,s.jsxs)(n.p,{children:["Annotations are used to add custom information to definitions, the prefixed ",(0,s.jsx)(n.strong,{children:"@"})," acts as a protection against conflicts with built-in/standard properties. They are flat lists of key-value pairs, with keys being fully qualified property names and values being represented as introduced in section Literals."]}),"\n",(0,s.jsx)(n.p,{children:"This yields the following pattern for top-level and for element annotations:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'{\n  "definitions": {\n    "<entity name>": {\n      "kind": "entity",\n      "@<entity annotation name>": <annotation value>,\n      "elements": {\n        "<element name>": {\n          "type": "<type name>",\n          "@<element annotation name>": <annotation value>,\n        }\n      }\n    }\n  }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The CSN Interop spec also defines a set of ",(0,s.jsx)(n.a,{href:"./annotations",children:"aligned, interoperable annotations"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"standard-annotations",children:"Standard Annotations"}),"\n",(0,s.jsxs)(n.p,{children:["Formally any annotation following the syntax pattern prefixed with ",(0,s.jsx)(n.strong,{children:"@"})," is allowed. However, annotations can only be interpreted safely by consumers if they follow a common specification. For SAP-internal interoperability, a standard process is in place on how to contribute standard annotations. It is especially applied by S/4HANA and also by Datasphere. Producers are encouraged to reuse existing standard ",(0,s.jsx)(n.a,{href:"./annotations",children:"annotations"})," and publish their specialized semantics also in this way."]}),"\n",(0,s.jsx)(n.h3,{id:"literals-for-enum-and-elementref-values",children:"Literals for Enum and ElementRef values"}),"\n",(0,s.jsx)(n.p,{children:"An annotation value of type Enum shall be given as an enum symbol:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'"<definition name>": {\n  "<annotation key of type Enum>": { "#": "<enum value>" }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"An annotation value of type ElementRef can be given in two formats: as a reference (preferred)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'"<definition name>": {\n  "<annotation key of type ElementRef>": { "=": "<element name>" }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"or as a string"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'"<definition name>": {\n  "<annotation term of type ElementRef>": "<element name>"\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"(In CDL notation this is the difference between\n<annotation term>: <element name> (CAP style)\nand\n<annotation term>: \u2018<element name>\u2019 (RAP style)\n)"}),"\n",(0,s.jsx)(n.h3,{id:"language-dependent-annotation-values",children:"Language-dependent annotation values"}),"\n",(0,s.jsxs)(n.p,{children:["Some annotations have language-dependent values, e.g. ",(0,s.jsx)(n.a,{href:"./annotations/enduser-text",children:(0,s.jsx)(n.code,{children:"@EnduserText"})}),".\nIf in such cases a plain string is provided, the language is unspecified. Consumers will typically default English in this case, e.g."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'"FlightDate": {\n  "@EndUserText.label": "Flight Date"\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Therefore providers shall either provide values in English or, if more languages are available, apply the following localization notation:\nconcatenate ",(0,s.jsx)(n.code,{children:"{i18n>labelID}"}),",\nwhere ",(0,s.jsx)(n.code,{children:"<label ID\\>"})," uniquely refers to an i18n entry, e.g."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'"FlightDate": {\n  "@EndUserText.label": "{i18n>FlightDate}"\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"i18n entries (key/value pairs) can be provided as part of the CSN document, as described in section Localization (i18n)."}),"\n",(0,s.jsx)(n.h2,{id:"associations",children:"Associations"}),"\n",(0,s.jsx)(n.p,{children:"An Association expresses a relation between two entities. An association is directed from the source to the target and always defined at the source."}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"Note:\nBidirectional relations can be defined via associations at both related entities. This is often not necessary, however, because the consumer can derive the inverse relation from a single association."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Associations are element definitions with ",(0,s.jsx)(n.em,{children:"type"})," being ",(0,s.jsx)(n.em,{children:"cds.Association"})," or ",(0,s.jsx)(n.em,{children:"cds.Composition"})," plus additional properties specifying the association ",(0,s.jsx)(n.em,{children:"target"}),", the ",(0,s.jsx)(n.em,{children:"cardinality"}),", and an ",(0,s.jsx)(n.em,{children:"on"})," condition."]}),"\n",(0,s.jsxs)(n.p,{children:["Property ",(0,s.jsx)(n.em,{children:"cardinality"})," is an object {",(0,s.jsx)(n.em,{children:"src?"}),",",(0,s.jsx)(n.em,{children:"min?"}),",",(0,s.jsx)(n.em,{children:"max"}),"} with..."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.em,{children:"src"})," set to 1 give a hint to database optimizers, that a source entity always exists"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.em,{children:"min"})," specifying the target's minimum cardinality (0, 1, *) \u2013 default: 0"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.em,{children:"max"})," specifying the target's maximum cardinality (1, *) \u2013 default: 1"]}),"\n",(0,s.jsxs)(n.li,{children:["In summary, the default cardinality is ",(0,s.jsx)(n.em,{children:"[0..1]"}),", which means ",(0,s.jsx)(n.em,{children:"to-one"}),". However, we recommend to always specify the cardinality, in order to avoid uncertainties on the consumer side."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The semantics follows from the pattern <src>:[<min>..<max>]. Most typical are the following:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Cardinality"}),(0,s.jsx)(n.th,{children:"CDL"}),(0,s.jsx)(n.th,{children:"CSN"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"To-one"}),(0,s.jsx)(n.td,{children:"[0..1], short: [1]"}),(0,s.jsx)(n.td,{children:'{ "min": 0, "max": 1 }, short: { "max": 1 }'})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"To-many"}),(0,s.jsxs)(n.td,{children:["[0..",(0,s.jsx)(n.em,{children:"], short: ["}),"]"]}),(0,s.jsxs)(n.td,{children:['{ "min": 0, "max": "',(0,s.jsx)(n.em,{children:'" }, short: { "max": "'}),'" }']})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:["The (mandatory) ",(0,s.jsx)(n.em,{children:"on"})," property maps elements of the local entity to elements of the target entity. Its syntax and grammar follows the Core Query Notation (CQN), which at its core is a JSON representation for SQL queries. The subset of CQN required to construct on-conditions of associations is explained in the next sub section. So far we have:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'{\n  "definitions": {\n    "<source entity name>": {\n      "kind": "entity",\n      "elements": {\n        "<association name>": {\n          "type": "cds.Association", // or cds.Composition\n          "target": "<target entity name>",\n          "cardinality": {\n            "src": <source cardinality>,     // 1 - optional\n            "min": <target min cardinality>, // 0, 1\n            "max": <target max cardinality>  // 1, "*"\n          },\n          "on": [\n            <predicate expression>\n          ]\n        }\n      }\n    }\n  }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"on-condition",children:"On Condition"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.em,{children:"on"})," condition is a predicate expression in ",(0,s.jsx)(n.a,{href:"https://cap.cloud.sap/docs/cds/cxn#expressions",children:"CXN"}),' format, which binds elements of the target entity.\nIn this version of the spec we limit the scope to bindings via the "=" operator, and logical operators between single target element bindings to "and".\nAn operand can either refer to an element, or can be given as a fix value (a literal). Fix values are notated as a property ',(0,s.jsx)(n.em,{children:"val"})," containing a literal. Element references are notated as a property ",(0,s.jsx)(n.em,{children:"ref"})," containing a path to the element in question, given as an array of element names. The last entry in the array is the unqualified element name.\nThus an element in an association target is uniquely referred to by a an array with two entries: The association name, and the name of the element in the target entity (short: target element). An element in the source/local entity does not need further qualification and shall be given by a single entry with the name of the source element.\nSo within this scope of expressiveness the pattern of an association\u2019s on condition looks like this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'\u2026\n        "on": [\n          {\n            "ref": [\n              "<association name>",\n              "<target element name in target entity>"\n            ]\n          },\n          "=",\n          {\n            "ref": [                          // or "val": <value>\n              "<element name in source entity>"\n            ]\n          },\n          "and",\n          {\n            "ref": [\n              "<association name>",\n              "<another element name in target entity>"\n            ]\n          },\n          "=",\n          {\n            "val": <value>        // or "ref": [ <source element name> ]\n          },\n          // "and" ...\n        ]\n'})}),"\n",(0,s.jsx)(n.p,{children:'Note that that commutation rules of logical expressions apply, i.e. the sequence of expressions combined with and "=" or with an "and" is not significant and can thus be arbitrarily chosen. (As we want to bind target elements it is natural to start with those on the left side of the equation.)\nFurther note that the usual operator precedencies apply, especially "=" operators are applied first and only then "and" operators. It is not necessary to add brackets in this case. (Brackets would be given as an "(" or ")" entry in the array, at the place of their occurrence.)'}),"\n",(0,s.jsx)(n.h3,{id:"foreign-key-associations",children:"Foreign Key Associations"}),"\n",(0,s.jsx)(n.p,{children:'The most relevant class of associations for data integration are foreign key associations, which point to the list of values ("check table") for a local element. Foreign key associations are of cardinality to-one and typically bind exactly all key elements of the target entity.\nAs the association is itself an element, the information for which element it is the foreign key association is expressed via a standard annotation.\nFor a single target key element, the pattern looks like:'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'{\n  "definitions": {\n    "<entity name>": {\n      "kind": "entity",\n      "elements": {\n        "<local element name>": {\n          "type": "<type name>",\n          "@ObjectModel.foreignKey.association": {\n            "=": "<foreign key association name>"\n          }\n        },\n        "<foreign key association name>": {\n          "type": "cds.Association",\n          "target": "<other entity name>",\n          "cardinality": {\n            "min": 0,\n            "max": 1\n          },\n          "on": [\n            {\n              "ref": [\n                "<foreign key association name>",\n                "<key element name>"\n              ]\n            },\n            "=",\n            {\n              "ref": [\n                "<local element name>"\n              ]\n            }\n          ]\n        }\n      }\n    },\n    "<other entity name>": {\n      "kind": "entity",\n      "elements": {\n        "<key element name>": {\n          "type": "<type name>",\n          "key": true\n        }\n      }\n    }\n  }\n};\n'})}),"\n",(0,s.jsx)(n.p,{children:"We recommend to add foreign associations wherever this relation applies."}),"\n",(0,s.jsx)(n.h3,{id:"text-associations",children:"Text Associations"}),"\n",(0,s.jsx)(n.p,{children:'Another important class of associations are text associations, which point to language-dependent texts (a "text table") for an ID. Text associations are formally of cardinality to-many, but they bind exactly all key elements of the target entity, except the language key. (So in a runtime context, when the language is fixed, the effective cardinality is to-one.)\nThe definition pattern in CSN is very similar to foreign key associations:'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'{\n  "definitions": {\n    "<entity name>": {\n      "kind": "entity",\n      "elements": {\n        "<local id element name>": {\n          "type": "<type name>",\n          "key": true\n          "@ObjectModel.text.association": {\n            "=": "<text association name>"\n          }\n        },\n        "<text association name>": {\n          "type": "cds.Association",\n          "target": "<text entity name>",\n          "cardinality": {\n            "min": 0,\n            "max": "*"\n          },\n          "on": [\n            {\n              "ref": [\n                "<text association name>",\n                "<id element name>"\n              ]\n            },\n            "=",\n            {\n              "ref": [\n                "<local id element name>"\n              ]\n            }\n          ]\n        }\n      }\n    },\n    "<text entity name>": {\n      "kind": "entity",\n      "@ObjectModel.modelingPattern": {\n        "#": "LANGUAGE_DEPENDENT_TEXT"\n      },\n      "elements": {\n        "<id element name>": {\n          "type": "<type name>",\n          "key": true\n        },\n        "<language element name>": {\n          "type": "cds.String",\n          "length": <length>,\n          "key": true,\n          "@Semantics.language": true\n        },\n        "<text element name>": {\n          "type": "cds.String",\n          "length": <length>,\n          "@Semantics.text": true\n        }\n        // optional: more elements (text, or non-text)\n      }\n    }\n  }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"We recommend to add text associations wherever this relation applies."}),"\n",(0,s.jsx)(n.h2,{id:"context-definitions",children:"Context Definitions"}),"\n",(0,s.jsxs)(n.p,{children:["All definitions names must be unique within the CSN document. However, sometimes the data models to be defined do not share the same namespace on the provider side. A typical example in the context of deployment is that a single CSN document may contain table definitions for several schemas. In this case the table names are unique within the schema. Another example is that a CSN document spans across several, separate application areas. In this case the names may only be unique per application area.\nIn order to arrive at unique entity names in CSN, a ",(0,s.jsx)(n.a,{href:"./spec-v1/csn-interop-effective#context-definition",children:"context"}),' is defined. And all data definitions with an original name locally unique to this context are prefixed with the context name, separated by a ".". The basic pattern is thus:']}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'{\n  "definitions": {\n    "<context name>": {\n      "kind": "context"\n    },\n    "<context name>.<locally unique name>": {\n      "kind": "<kind>"\n    }\n  }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Sometimes contexts have specific semantics which shall be expressed (e.g. by a label). Also, contexts can be logically nested and may have different semantics, depending on the nesting level. In these cases the contexts could carry additional metadata in terms of annotations. The resulting pattern is a compatible extension of the basic context pattern (here given for entity definitions):"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'{\n  "definitions": {\n    "<context name level 1>": {\n      "kind": "context",\n      "@<annotation name>": <annotation value>\n    };\n    "<context name level 1>.<context name level 2>": {\n      "kind": "context",\n      "@<annotation name>": <annotation value>\n    };\n    "<context name level 1>.<context name level 2>.<local entity name>": {\n      "kind": "entity",\n      "elements": { \u2026 }\n    };\n  }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Note that logically nested contexts are not formally nested in CSN, but flattened in a way that the more specific context uses the higher-level context as part of its name, just according to the basic pattern above.\nFurther note that element names are not affected by context definitions, because element names are anyway local to the entity name."}),"\n",(0,s.jsx)(n.h3,{id:"aggregation-of-data-definitions",children:"Aggregation of Data Definitions"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.em,{children:"Contexts"})," can also be used to aggregate local data definitions into a single CSN document. E.g. assume that there are several original data models, each of which where local to a schema. And each of these data models is already described in terms of data definitions in CSN format.\nNow simply merging these data definitions into one is typically not possible because in the resulting CSN document the definition names must again be unique. But the data definitions can be rewritten by introducing higher-level contexts (e.g. one context per schema), and replacing all local names by their fully qualified equivalents.\nNote that it is not sufficient to replace the top-level data definition names, but that also the association targets and annotation values of type ",(0,s.jsx)(n.em,{children:"EntityRef"})," have to be adapted."]}),"\n",(0,s.jsx)(n.h2,{id:"custom-type-definitions",children:"Custom Type Definitions"}),"\n",(0,s.jsx)(n.p,{children:"Sometimes built-in types are not sufficient. In general, CDS supports scalar, structured and arrayed types. The CSN Interop Effective spec decided to not support arrayed types, as due to lack of support in relational databases (therefore not sufficient interoperability)."}),"\n",(0,s.jsx)(n.p,{children:"This section explains how they are handled in Effective CSN.\nNote that all used types, which are not built-in types, must be explicitly defined (based on built-in types or other defined types)."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'{\n  "definitions": {\n    "<type name>": {\n      "kind": "type"\n    }\n  }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"scalar-types",children:"Scalar Types"}),"\n",(0,s.jsx)(n.p,{children:"Scalar types are type definitions, with a mandatory property type."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'{\n  "definitions": {\n    "type name": {\n      "kind": "type",\n      "type": "<built-in type or custom type name>"\n    }\n  }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"For some built-in types additional properties are required.\nIn Effective CSN type definitions shall be introduced only for a good reason. Consider that consumers will either use a standard type system (like CDS or HANA), or will have their local type system, and may not be able to consume external types 1:1, but need to resolve them anyway.\nThere are however known scenarios, where a systematic usage of own type definitions may be considered (it is still a trade-off decision),"}),"\n",(0,s.jsx)(n.h4,{id:"local-built-in-types",children:"Local Built-in Types"}),"\n",(0,s.jsx)(n.p,{children:"If the provider stack has an own built-in type system, it may be more efficient and also safer (from a quality perspective) to define the data models in terms of the local built-in types and add a mapping to the CDS built-in types.\nFor example, RAP uses the ABAP built-in types, where e.g. the date is represented as an 8-digit string following the pattern \u2018YYYYMMDD\u2019. There are three alternative ways to deal with this situation in Effective CSN:"}),"\n",(0,s.jsx)(n.p,{children:"1)Replace all date type usages by cds.Date (challenge: This effects the data exchange format.)\n2)Replace all date type usages by cds.String(8) (challenge: loss of semantics)\n3)Define a type abap.dats based on cds.String and keep using the ABAP type (challenge: shall consumers understand/leverage this type system? Or will they resolve to 2) anyway?)"}),"\n",(0,s.jsx)(n.p,{children:"Example for 3):"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'    "abap.dats": {\n      "kind": "type",\n      "type": "cds.String",\n      "length": 8,\n      "@Semantics.date": true   // optional\n    }\n'})}),"\n",(0,s.jsx)(n.h4,{id:"semantic-types",children:"Semantic Types"}),"\n",(0,s.jsx)(n.p,{children:'If the provider already locally declared semantic types which are reused in several data models, then it may be desirable to capture this semantics for consumers who can also support semantic types.\nE.g. the ABAP Dictionary has "Data Elements" which are scalar public types, with a description (and other properties). Typical usages are business-semantics (e.g. "Controlling Area") and public semantics (e.g. "Fiscal Year").\nIn case of master data the preferred technique to express the reuse in Effective CSN is to add a foreign key association to each element which represents the master data ID. All these foreign key associations will have the same target entity, which thus fully compensates for a dedicated semantic type.\nIn case of public semantic types the default pattern in CSN is to annotate the semantics at each element (e.g. @Semantics.fiscal.year: true).\nWe recommend to apply these default techniques always, even in the case where explicit semantic types are defined. (Which in turn reduces the additional value of exposing semantic type definitions.)\nExample for a semantic type definition:'}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'    "r3.FISCYEAR": {\n      "kind": "type",\n      "type": "cds.String",\n      "length": 4,\n      "@EndUserText.label": "Fiscal Year"\n      "@Semantics.fiscal.year": true\n    }\n'})}),"\n",(0,s.jsx)(n.p,{children:"Note that a namespace is typically required to separate it from other type systems and from entity definitions.\nIn this example we would recommend to resolve the semantics at each usage (i.e. replace it by the built-in type and add the annotations.)"}),"\n",(0,s.jsx)(n.h3,{id:"structured-types",children:"Structured Types"}),"\n",(0,s.jsx)(n.p,{children:"CDS CDL (and thus CSN) supports the definition of structured types, which then can be used in the type properties of entity elements, or in other type definitions. While this kind of nesting can be elegant at design time, it is problematic for interoperability as it requires advanced consumers to resolve it. And even if the consumer can resolve it, the exact mapping to the persistency layer (in terms of table column names) is not determined and may depend on local conventions.\nTherefore, in Effective CSN we expect structured types to be resolved before using them at entity elements. Effective CSN supports two resolution patterns:"}),"\n",(0,s.jsx)(n.h4,{id:"inlining",children:"Inlining"}),"\n",(0,s.jsx)(n.p,{children:'Inlining means that a structured type is (recursively, if nested itself) dereferenced into an elements section at each place it is used. In entities this leads to a nested elements property (example: "Price": { elements: { "Currency", "Amount" } ).\nNote: This version of the doc does not provide a reference for inline structured types.'}),"\n",(0,s.jsx)(n.h4,{id:"flattening",children:"Flattening"}),"\n",(0,s.jsx)(n.p,{children:'If the structured type does not serve any particular purpose at deployment or for consumers, structured types can also be flattened in a way that the nested elements section after inlining are replaced by concatenated element names (e.g. separated by "_"; example: "Price_Currency", "Price_Amount").'}),"\n",(0,s.jsx)(n.h2,{id:"service-definitions",children:"Service Definitions"}),"\n",(0,s.jsxs)(n.p,{children:["CDS allows to define service interfaces as collections of exposed entities enclosed in a ",(0,s.jsx)(n.em,{children:"service"})," section, which is essentially a ",(0,s.jsx)(n.em,{children:"context"}),".(Especially the service acts as a name prefix for the exposed entities.)\nThe exposed entities are typically projections on entities from underlying data models, defined via standard view definitions."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'{\n  "definitions": {\n    "<service name>": {\n      "kind": "service",\n      "@<context annotation name>": <annotation value>\n    },\n    "<service name>.<exposed entity name>": {\n      "kind": "entity",\n      "elements": {\n      }\n    },\n    ...\n  }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"localization-i18n",children:"Localization (i18n)"}),"\n",(0,s.jsx)(n.p,{children:"A CSN document may optionally contain a top-level i18n property, which can contain translated texts. The expected structure is as follows:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'{\n  "i18n": {\n    "<language key": {\n      "<text key>": "<text>"\n    }\n  }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"In the context of Effective CSN it is especially relevant to expose language-dependent annotation values in several languages. Example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'{\n  "definitions": {\n    "FlightConnection": {\n      "kind": "entity",\n      "@EndUserText.label": "{i18n>FlightConnection}",\n      "elements": {\n        "ConnectionID": {\n          "@EndUserText.label": "{i18n>ConnectionID}",        }\n      }\n    }\n  },\n  "i18n": {\n    "en": {\n      "FlightConnection": "Flight Connection",\n      "ConnectionID": "Flight Number"\n    },\n    "de": {\n      "FlightConnection": "Flugverbindung",\n      "ConnectionID": "Flugnummer"\n    }\n  }\n}\u2003\n'})}),"\n",(0,s.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.a,{href:"./spec-v1/examples/airline",children:"airline example"})," of the Primer and other examples can be found here: ",(0,s.jsx)(n.a,{href:"/csn-interop-specification/spec-v1/examples/",children:"Examples"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>r});var i=t(6540);const s={},a=i.createContext(s);function o(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);